#!/bin/python3
import glob
import os
import random
import string
import shutil
import subprocess
import tarfile
import argparse
import io
from tempfile import TemporaryDirectory

__author__ = "Gareth Dunstone"
__copyright__ = "Copyright 2016, Borevitz Lab"
__credits__ = ["Gareth Dunstone", "Tim Brown", "Justin Borevitz", "Kevin Murray", "Jack Adamson"]
__license__ = "GPL"
__version__ = "3.0.2"
__maintainer__ = "Gareth Dunstone"
__email__ = "gareth.dunstone@anu.edu.au"
__status__ = "Testing"

class BColors:
    header = '\033[95m'
    blue = '\033[94m'
    green = '\033[92m'
    warn = '\033[93m'
    fail = '\033[91m'
    endc = '\033[0m'
    bold = '\033[1m'
    under = '\033[4m'

def printc(text, *args):
    print("".join(args)+text+BColors.endc)

def printr(text):
    print("\x1b[1G\x1b[K", text, sep="", end="")


global_char_pos = 0

def progressbar(current,total):
    global global_char_pos
    term_width = shutil.get_terminal_size((80, 20)).columns-2
    progress_char_pos = int((current / total) * term_width)
    if progress_char_pos != global_char_pos:
        global_char_pos = progress_char_pos
        col = BColors.green
        if progress_char_pos <= term_width/3:
            col = BColors.warn
        elif term_width/3 <= progress_char_pos <= term_width*(2/3):
            col = BColors.header
        s = "".join("X" if x < progress_char_pos else " " for x in range(term_width))
        printr(col+"[{}]".format(s)+BColors.endc)
        os.sync()


parser = argparse.ArgumentParser(description="Flash spc-eyepi sd card")
parser.add_argument("blockdevice", metavar='d', type=str, nargs=1,
                    help="Block device/devices to copy data to")
parser.add_argument("--tarfile", metavar="t", type=argparse.FileType('rb'),
                    help="tar/tar.gz file to flash to the card")
parser.add_argument("--api-token", metavar='k', type=str,
                    help="traitcapture api token for automated addition to database")
parser.add_argument("--update", default=False,action='store_true',
                    help="dont flash new data to the card, update the software and set the name if required.")
parser.add_argument("--removekeys", default=False, action='store_true',
                    help="clear ssh keys.")
parser.add_argument("--backup", metavar='b',
                    help="backup the tor encryption keys, ssh encryption keys, and camera config files to a directory.")
parser.add_argument("--restore", metavar='r',
                    help="restore tor encryption keys, ssh encryption keys, and camera config files from a directory.")
parser.add_argument("--name", metavar='n', type=str,
                    help="name of the raspberry pi (will be autogenerated if not provided)")

args = parser.parse_args()

RAND = "".join((random.choice(string.ascii_letters) for _ in range(6)))
if not args.name:
    printc("No name provided. autogenerated: {} for a name".format("Picam-"+RAND), BColors.warn)

gname = "Picam-"+RAND if not args.name else args.name


def mkdir_mount():
    os.getenv("TMPDIR")
    temp_directory = os.path.join('/tmp/spc_os/', RAND)
    printc("Temporary directory: {}".format(temp_directory), BColors.under)
    d = glob.glob(args.blockdevice[0]+"*")
    d.sort()
    d.pop(0)
    os.makedirs(os.path.join(temp_directory, "boot"), exist_ok=True)
    os.makedirs(os.path.join(temp_directory, "root"), exist_ok=True)
    if not len(d) >= 2:
        printc("didnt find 2 partitions on the block device to mount...", BColors.warn)
        return temp_directory
    try:
        printc("Mounting {}".format(" ".join(d)), BColors.under)
        cmdstring = "mount {block_device} {path}"
        # os.system("mount {} {}".format(d[0], os.path.join(temp_directory, "boot")))
        v = subprocess.run([cmdstring.format(block_device=d[0], path=os.path.join(temp_directory, "boot"))],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           shell=True, universal_newlines=True)
        v.check_returncode()
        # os.system("mount {} {}".format(d[1], os.path.join(temp_directory, "root")))

        z = subprocess.run([cmdstring.format(block_device=d[1], path=os.path.join(temp_directory, "root"))],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           shell=True, universal_newlines=True)
        z.check_returncode()
        printc("Mounted", BColors.under)
    except subprocess.CalledProcessError as e:
        printc("Couldnt call mount {}\n{}".format(str(e),str(e.output)), BColors.fail)
    except Exception as e:
        printc("Something went wrong mounting: {}".format(str(e)), BColors.fail)
    return temp_directory


def cleanup(tmpdir, block_device):
    printc("Unmounting {}".format(block_device[0]), BColors.under)
    cmdstring = "umount {}?"
    try:

        v = subprocess.check_output([cmdstring.format(block_device[0])],
                           stderr=subprocess.STDOUT,
                           shell=True, universal_newlines=True)
        printc("Unmounted {}".format(block_device[0]), BColors.under)
    except subprocess.CalledProcessError as e:
        printc("Couldnt call umount: {}\n{}".format(str(e), str(e.output)), BColors.fail)
    except Exception as e:
        printc("Some other exception occured during the unmounting process: {}".format(str(e)), BColors.fail)
    printc("Removing temp {}".format(tmpdir), BColors.under)
    shutil.rmtree(tmpdir)
    os.sync()


def write_api_token(tmpdir):
    import requests, json
    resp = requests.get("https://traitcapture.org/api/code/new/14.jsonp?token=" + args.api_token)
    if resp.status_code == 200:
        try:
            js = json.loads(resp.text)
            from pprint import pformat
            printc(pformat(js), BColors.blue)
            ssh_dir = os.path.join(tmpdir, "root", "home", ".ssh")
            os.makedirs(ssh_dir, exist_ok=True)
            with open(os.path.join(ssh_dir, "key_token"), 'w') as f:
                f.write(js['code'])
        except KeyError:
            printc("Server didnt respond with a valid code", BColors.fail)

        except Exception as e:
            printc("Couldnt get token using key: {}".format(str(e)), BColors.fail)

    else:
        printc("invalid response from server {}".format(str(resp)),BColors.fail )


def backup_old(tmpdir):
    printc("copying old files over...",BColors.blue)
    with open(os.path.join(tmpdir, "root", "hostname"), 'r') as f:
        hostname = f.read().strip()
    bakdir = "{}.bak".format(hostname)
    os.makedirs(bakdir)
    os.makedirs(os.path.join(bakdir, "configs"), exist_ok=True)
    os.makedirs(os.path.join(bakdir, "tor_private"), exist_ok=True)
    os.makedirs(os.path.join(bakdir, ".ssh"), exist_ok=True)
    shutil.copy(os.path.join(tmpdir, "root", "etc", "hostname"), os.path.join(bakdir, "hostname"))
    shutil.copy(os.path.join(tmpdir, "root", "home", "spc-eyepi", "configs_byserial"), os.path.join(bakdir, "configs"))
    shutil.copy(os.path.join(tmpdir, "root", "home", "spc-eyepi", "tor_private"), os.path.join(bakdir, "tor_private"))
    shutil.copy(os.path.join(tmpdir, "root", "home", ".ssh"), os.path.join(bakdir, "ssh"))


def restore(tmpdir, bakdir=None):
    if not bakdir:
        with open(os.path.join(tmpdir, "root", "hostname"), 'r') as f:
            hostname = f.read().strip()
        bakdir = "{}.bak".format(hostname)

    if os.path.exists(bakdir):
        shutil.copy(os.path.join(bakdir, "hostname"), os.path.join(tmpdir, "root", "etc", "hostname"))
        shutil.copy(os.path.join(bakdir, "configs"), os.path.join(tmpdir, "root", "home", "spc-eyepi", "configs_byserial"))
        shutil.copy(os.path.join(bakdir, "tor_private"), os.path.join(tmpdir, "root", "home", "spc-eyepi", "tor_private"))
        shutil.copy(os.path.join(bakdir, "ssh"), os.path.join(tmpdir, "root", "home", ".ssh"))
        if args.api_token:
            write_api_token(tmpdir)

        if os.path.isfile(os.path.join(bakdir, "hostname")):
            with open(os.path.join(bakdir, "hostname"),'r') as hostname_file:
                with open(os.path.join(tmpdir, "root", "etc", "hosts"), 'w') as hosts_file:
                    h_tmpl = "127.0.0.1\tlocalhost.localdomain localhost {hostname}\n::1\tlocalhost.localdomain localhost {hostname}\n"
                    hosts_file.write(h_tmpl.format(hostname=hostname_file.read().strip()))
        printc("Completed restore", BColors.header)
    else:
        printc("Error: backup dir doesnt exist...", BColors.fail)


def update_via_github(temp_dir):
    eyepi_dir = os.path.join(temp_dir, "root", "home", "spc-eyepi")
    git_dir = os.path.join(eyepi_dir, ".git")
    try:
        os.system("git --git-dir={} --work-tree={} fetch --all".format(git_dir, eyepi_dir))
        os.system('git --git-dir={} --work-tree={} reset --hard origin/master'.format(git_dir, eyepi_dir))
        x = subprocess.run(["git --git-dir={} --work-tree={} fetch --all".format(git_dir, eyepi_dir)],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           shell=True, universal_newlines=True)
        x.check_returncode()
        x = subprocess.run(['git --git-dir={} --work-tree={} reset --hard origin/master'.format(git_dir, eyepi_dir)],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                           shell=True, universal_newlines=True)
        x.check_returncode()
        v = subprocess.check_output(["git --git-dir={} --work-tree={} describe".format(git_dir, eyepi_dir)],
                                    shell=True, universal_newlines=True)
        q = subprocess.check_output(["git --git-dir={} --work-tree={} log -1 --pretty=%B".format(git_dir, eyepi_dir)],
                                    shell=True, universal_newlines=True)
        z = subprocess.check_output(
            ["git --git-dir={} --work-tree={} show -s --format=%cd --date=local".format(git_dir, eyepi_dir)],
            shell=True, universal_newlines=True)

        printc("Now at:\n\n{}{}{}".format(v, z, q), BColors.blue)
        printc("Completed update", BColors.header)
    except subprocess.CalledProcessError as e:
        printc("Couldnt call git: {}".format(str(e)), BColors.fail)
    except Exception as e:
        printc("Exception while updating from github: {}".format(str(e)), BColors.fail)


def format_create_new(tmpdir=None):
    if tmpdir:
        cleanup(tmpdir, args.blockdevice)
    printc("Creating new partition table with fdisk...", BColors.warn)
    with subprocess.Popen(["/usr/bin/fdisk", "{}".format(args.blockdevice[0])],
                          stdin=subprocess.PIPE, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                          universal_newlines=True) as proc:
        # create boot partition of size 100M
        proc.stdin.write("o\nn\np\n\n\n+100M\n")
        proc.stdin.flush()
        # make w95 fat for rpi :(
        proc.stdin.write("t\nc\n")
        proc.stdin.flush()
        # create linux partition to fill the rest of the disk.
        proc.stdin.write("n\n\n\n\n\n")
        proc.stdin.flush()

        # write to disk
        proc.stdin.write("w\n")
        proc.stdin.flush()
        # get rid of fdisk.
        proc.communicate()

    printc("Creating fat32 boot filesystem (for raspberry pi firmware and bootloader).", BColors.warn)
    with subprocess.Popen(["/usr/bin/mkfs.vfat", "{}".format(args.blockdevice[0]+"1")],
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                          universal_newlines=True) as proc:
        proc.communicate()

    printc("Creating ext4  root filesystem (for the os).", BColors.warn)
    with subprocess.Popen(["/usr/bin/mkfs.ext4", "{}".format(args.blockdevice[0] + "2")],
                        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                          universal_newlines=True) as proc:
        proc.communicate()


class ProgressFileObject(io.FileIO):
    def __init__(self, path, *args, **kwargs):
        self._total_size = os.path.getsize(path)
        super().__init__(path, *args, **kwargs)
        # io.FileIO.__init__(self, path, *args, **kwargs)

    def read(self, size=-1):
        progressbar(self.tell(), self._total_size)
        return io.FileIO.read(self, size)


tarfile.TarFile.fileobject = ProgressFileObject


def extract_new(tmpdir, tar_file_object):
    printc("Extracting: {}".format(tar_file_object.name), BColors.blue)
    with tarfile.open(fileobj=ProgressFileObject(tar_file_object.name), mode='r') as tar:
        try:
            tar.extractall(path=tmpdir)
            print("")
            printc("Tar extraction completed", BColors.header)
        except KeyError:
            printc("tar file doesnt have the correct subdirs", BColors.fail)
        except Exception as e:
            printc("something went very wrong {}".format(str(e)), BColors.fail)


def set_hostname(tmpdir, hostname):
    printc("Fixing hostname and hosts file:", BColors.header)
    try:
        with open(os.path.join(tmpdir, "root", "etc", "hostname"), 'w') as f:
            f.write(hostname+"\n")

        with open(os.path.join(tmpdir, "root", "etc", "hosts"), 'w') as hosts_file:
            h_tmpl = "127.0.0.1\tlocalhost.localdomain localhost {hostname}\n::1\tlocalhost.localdomain localhost {hostname}\n"
            hosts_file.write(h_tmpl.format(hostname=hostname))
    except Exception as e:
        printc("Couldnt fix hostname {}".format(str(e)), BColors.fail)
    printc(hostname, BColors.bold, BColors.header)

if __name__ == '__main__':
    temp_dir = mkdir_mount()
    if not temp_dir:
        import sys
        printc("Something went horribly wrong and I couldnt create a temp dir correctly.", BColors.warn)
        sys.exit(1)
    if args.tarfile:
        printc("Formatting", BColors.header)
        format_create_new(temp_dir)
        printc("Extracting", BColors.header)
        temp_dir = mkdir_mount()
        extract_new(temp_dir, args.tarfile)
        set_hostname(temp_dir, gname)

    if args.update:
        printc("Updating", BColors.header)
        update_via_github(temp_dir)
        set_hostname(temp_dir, gname)

    if args.restore:
        printc("Restoring", BColors.header)
        restore(temp_dir, bakdir=args.backup_directory)

    elif args.backup:
        printc("Backing up", BColors.header)
        backup_old(temp_dir)

    if args.api_token:
        printc("Writing api token", BColors.header)
        write_api_token(temp_dir)

    if os.path.isfile("db"):
        printc("Writing db file", BColors.header)
        shutil.copy("db", os.path.join(temp_dir, "root", "home", "spc-eyepi", "db"))

    if os.path.isfile("db_private"):
        printc("Writing private db file", BColors.header)
        shutil.copy("db_private", os.path.join(temp_dir, "root", "home", "spc-eyepi", "db"))

    if args.removekeys:
        printc("Removing ssh keys", BColors.header)
        ssh_files = glob.glob(os.path.join(temp_dir,"root","home",".ssh","*"))
        for path in ssh_files:
            if not os.path.basename(path) == "key_token":
                os.remove(path)
            else:
                printc(".ssh dir has key token", BColors.green)

    if temp_dir:
        cleanup(temp_dir, args.blockdevice)