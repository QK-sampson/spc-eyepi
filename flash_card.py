import glob
import os
import random
import string
import shutil
import subprocess
import tarfile
import argparse

__author__ = "Gareth Dunstone"
__copyright__ = "Copyright 2016, Borevitz Lab"
__credits__ = ["Gareth Dunstone", "Tim Brown", "Justin Borevitz", "Kevin Murray"]
__license__ = "GPL"
__version__ = "3.2.5"
__maintainer__ = "Gareth Dunstone"
__email__ = "gareth.dunstone@anu.edu.au"
__status__ = "Testing"


parser = argparse.ArgumentParser(description="Flash spc-eyepi sd card")
parser.add_argument("block-device", metavar='d', type=str, nargs="+",
                    help="Block device/devices to copy data to")
parser.add_argument("--tarfile", metavar="t", type=argparse.FileType('rb'),
                    help="tar/tar.gz file to flash to the card")
parser.add_argument("--api-token", metavar='k', type=str,
                    help="traitcapture api token for automated addition to database")
parser.add_argument("--update", default=False,action='store_true',
                    help="dont flash new data to the card, update the software and set the name if required.")
parser.add_argument("--backup", metavar='b',
                    help="backup the tor encryption keys, ssh encryption keys, and camera config files to a directory.")
parser.add_argument("--restore", metavar='r',
                    help="restore tor encryption keys, ssh encryption keys, and camera config files from a directory.")
parser.add_argument("--name", metavar='n', type=str,
                    help="name of the raspberry pi (will be autogenerated if not provided)")

args = parser.parse_args()

RAND = "".join((random.choice(string.ascii_letters) for _ in range(6)))
if not args.name:
    print("No name provided. autogenerated: {} for a name".format("Picam-"+RAND))


def mkdir_mount():
    temp_directory = os.path.join('/tmp/spc_os/', RAND)
    d = glob.glob(args.block_device+"*")
    os.makedirs(os.path.join(temp_directory, "boot"), exist_ok=True)
    os.makedirs(os.path.join(temp_directory, "root"), exist_ok=True)
    if not len(d) >= 2:
        print("didnt find 2 partitions on the block device to mount...")
        return temp_directory
    try:
        print("Mounting {}".format(" ".join(d)))
        os.system("mount {} {}".format(d[0], os.path.join(temp_directory, "boot")))
        os.system("mount {} {}".format(d[1], os.path.join(temp_directory, "root")))
    except Exception as e:
        print(str(e))
    return temp_directory


def cleanup(temp_dir):
    d = glob.glob(temp_dir)
    for x in d:
        os.system("umount {}".format(d))
    shutil.rmtree(temp_dir)


def write_api_token(tmpdir):
    import requests, json
    resp = requests.get("https://traitcapture.org/api/code/new/14?token=" + args.api_token)
    if resp.status_code == 200:
        try:
            js = json.loads(resp.text)
            ssh_dir = os.path.join(tmpdir, "/root/home/spc-eyepi/.ssh")
            os.makedirs(ssh_dir, exist_ok=True)
            with open(os.path.join(ssh_dir, "token"), 'w') as f:
                f.write(js['code'])
        except Exception as e:
            print("Couldnt get token using key")

    else:
        print("invalid response from server")

def backup_old(tmpdir):
    print("copying old files over...")
    with open(os.path.join(tmpdir, "root", "hostname"), 'r') as f:
        hostname = f.read().strip()
    bakdir = "{}.bak".format(hostname)
    os.makedirs(bakdir)
    os.makedirs(os.path.join(bakdir, "configs"), exist_ok=True)
    os.makedirs(os.path.join(bakdir, "tor_private"), exist_ok=True)
    os.makedirs(os.path.join(bakdir, ".ssh"), exist_ok=True)
    shutil.copy(os.path.join(tmpdir, "/root/etc/hostname"), os.path.join(bakdir, "hostname"))
    shutil.copy(os.path.join(tmpdir, "/root/home/spc-eyepi/configs_byserial"), os.path.join(bakdir, "configs"))
    shutil.copy(os.path.join(tmpdir, "/root/home/spc-eyepi/tor_private"), os.path.join(bakdir, "tor_private"))
    shutil.copy(os.path.join(tmpdir, "/root/home/spc-eyepi/.ssh"), os.path.join(bakdir, "ssh"))

def restore(tmpdir, bakdir=None):
    if not bakdir:
        with open(os.path.join(tmpdir, "root", "hostname"), 'r') as f:
            hostname = f.read().strip()
        bakdir = "{}.bak".format(hostname)

    if os.path.exists(bakdir):
        shutil.copy(os.path.join(bakdir, "hostname"), os.path.join(tmpdir, "/root/etc/hostname"))
        shutil.copy(os.path.join(bakdir, "configs"), os.path.join(tmpdir, "/root/home/spc-eyepi/configs_byserial"))
        shutil.copy(os.path.join(bakdir, "tor_private"), os.path.join(tmpdir, "/root/home/spc-eyepi/tor_private"))
        if args.api_token:
            write_api_token(tmpdir)

        if os.path.isfile(os.path.join(bakdir, "hostname")):
            with open(os.path.join(bakdir, "hostname"),'r') as hostname_file:
                with open(os.path.join(tmpdir, "/root/etc/hosts"), 'w') as hosts_file:
                    h_tmpl = "127.0.0.1\tlocalhost.localdomain localhost {hostname}\n::1\tlocalhost.localdomain localhost {hostname}\n"
                    hosts_file.write(h_tmpl.format(hostname=hostname_file.read().strip()))
    else:
        print("backup dir doesnt exist...")

def update_via_github(temp_dir):
    eyepi_dir = os.path.join(temp_dir, "/root/home/spc-eyepi/")
    git_dir = os.path.join(eyepi_dir, ".git")
    try:
        os.system("git --git-dir={} --work-tree={} fetch --all".format(git_dir, eyepi_dir))
        os.system('git  --git-dir={} --work-tree={}  reset --hard origin/master'.format(git_dir, eyepi_dir))

    except Exception as e:
        print("Coulndt update from git, {}".format(str(e)))

def format_create_new(tmpdir=None):
    if tmpdir:
        cleanup(tmpdir)
    with subprocess.Popen(["/usr/bin/fdisk", "{}".format(args.block_device)],
                          stdin=subprocess.PIPE,
                          universal_newlines=True) as proc:
        # create boot partition of size 100M
        proc.stdin.write("o\nn\np\n\n\n+100M\n")
        proc.stdin.flush()
        # make w95 fat for rpi :(
        proc.stdin.write("t\nc\n")
        proc.stdin.flush()
        # create linux partition to fill the rest of the disk.
        proc.stdin.write("n\n\n\n\n\n")
        proc.stdin.flush()

        # write to disk
        proc.stdin.write("w\n")
        proc.stdin.flush()
        # get rid of fdisk.
        proc.communicate()

def extract_new(tmpdir, tar_file_obj):
    with tarfile.open(fileobj=tar_file_obj, mode='r') as tar:
        try:
            tar.getmember("root")
            tar.getmember("boot")

        except KeyError:
            print("tar file doesnt have the correct folders.")


if __name__ == '__main__':
    temp_dir = None
    if args.tarfile:
        print("Flashing anew")
        format_create_new()
        temp_dir = mkdir_mount()
        extract_new(temp_dir, args.tarfile)

    if args.update:
        print("Updating...")
        temp_dir = mkdir_mount()
        update_via_github(temp_dir)

    if args.restore:
        temp_dir = mkdir_mount()
        restore(temp_dir, bakdir=args.backup_directory)

    elif args.backup:
        temp_dir = mkdir_mount()
        backup_old(temp_dir)

    if args.api_token:
        write_api_token(temp_dir)

    if temp_dir:
        cleanup(temp_dir)

#
# if [ noconfirm ]
# then
#     tmp=/tmp/spc_os_format_$RANDOM
#     echo "Mounting ..."
#     mkdir -p $tmp/root
#     mkdir -p $tmp/boot
#     mount $devs[2] $tmp/root
#     mount $devs[1] $tmp/boot
#     echo "Untarring: "
#     tar xf *.tar --owner root --group root --no-same-owner -C $tmp --totals > /dev/null 2> $ERRLOG
#     echo "Syncing fs"
#     sync
#     umount $tmp/boot
#     umount $tmp/root
#     rm -rf $tmp
# else
#     read -p "Mounting and untarring $f[0],\n Continue (y/N)?" -n 1 -r
# 	if [[ $REPLY =~ ^[Yy]$ ]]
# 	then
# 	    tmp=/tmp/spc_os_format_$RANDOM
# 	    echo "Mounting ..."
# 	    mkdir -p $tmp/root
# 	    mkdir -p $tmp/boot
# 	    mount $devs[2] $tmp/root
# 	    mount $devs[1] $tmp/boot
# 	    echo "Untarring: "
# 	    tar xf *.tar --owner root --group root --no-same-owner -C $tmp --totals > /dev/null 2> $ERRLOG
# 	    echo "Syncing fs"
# 	    sync
# 	    umount $tmp/boot
# 	    umount $tmp/root
# 	    rm -rf $tmp
# 	fi
# fi
#
#!/bin/bash
# if [ $# -lt 1 ]
# then
#     echo "USAGE: $0 <block device> $1 <name>"
#     exit 1
# fi
#
# tmp=/tmp/SPC-OS_rename-$RANDOM
#
# mkdir -p $tmp/root
#
# mount $1 $tmp/root
#
# # copy latest spc-eyepi internals
# #cp /home/stormaes/Work/spc-eyepi3/webinterface.py $tmp/root/home/spc-eyepi/webinterface.py
# #cp /home/stormaes/Work/spc-eyepi3/capture-upload.py $tmp/root/home/spc-eyepi/capture-upload.py
# cd $tmp/root/home/spc-eyepi/ && git fetch --all && git reset --hard origin/python3 && cd /home/stormaes/Work/SPC-OS
# # string replace hostname to hostname and hosts files
# echo $2 > $tmp/root/etc/hostname
# echo "keys/$2"
# if [ -d "keys/$2" ]; then
#     echo "using stored keys"
#     cp keys/$2/hostname $tmp/root/etc/hostname
#     cp keys/$2/configs/* $tmp/root/home/spc-eyepi/configs_byserial
#     cp keys/$2/tor_private/* $tmp/root/home/tor_private
# else
#
# fi
# sed -i "/name/c\name=$2-Picam" $tmp/root/home/spc-eyepi/picam.ini
# sed -i "/name/c\name=$2" $tmp/root/home/spc-eyepi/eyepi.ini
# st="root\:x\:0\:0\:root\:\/home\:\/bin\/zsh"
# sed -i "1s/.*/$st/" $tmp/root/etc/passwd
#
#
# #fix for 0.6.0
# chown -R tor:tor $tmp/root/var/lib/tor
# chown -R tor:tor $tmp/root/home/tor_private
#
# # unmount and rm tmp folders
# umount $tmp/root
